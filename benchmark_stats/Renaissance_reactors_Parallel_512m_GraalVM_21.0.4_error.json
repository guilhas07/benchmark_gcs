{
    "garbage_collector": "Parallel",
    "jdk": "GraalVM_21.0.4",
    "benchmark_group": "Renaissance",
    "benchmark_name": "reactors",
    "heap_size": "512",
    "error": "Error code not found: 1\njava.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat java.base/java.lang.Class.getDeclaredConstructors0(Native Method)\n\tat java.base/java.lang.Class.privateGetDeclaredConstructors(Class.java:3549)\n\tat java.base/java.lang.Class.getDeclaredConstructors(Class.java:2727)\n\tat io.reactors.Platform$Reflect$.matchingConstructor(Platform.scala:223)\n\tat io.reactors.Platform$Reflect$.instantiate(Platform.scala:191)\n\tat io.reactors.Proto.create(Proto.scala:25)\n\tat io.reactors.concurrent.Frame.checkFresh(Frame.scala:237)\n\tat io.reactors.concurrent.Frame.processBatch(Frame.scala:491)\n\tat io.reactors.concurrent.Frame.isolateAndProcessBatch(Frame.scala:210)\n\tat io.reactors.concurrent.Frame.executeBatch(Frame.scala:183)\n\tat io.reactors.JvmScheduler$Executed$$anon$5.run(JvmScheduler.scala:255)\n\tat java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1423)\n\tat java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)\n\tat java.base/java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:667)\n\tat io.reactors.JvmScheduler$ReactorForkJoinWorkerThread.pollPool(JvmScheduler.scala:103)\n\tat io.reactors.JvmScheduler$ReactorForkJoinWorkerThread.postschedule(JvmScheduler.scala:150)\n\tat io.reactors.JvmScheduler$Executed.postschedule(JvmScheduler.scala:273)\n\tat io.reactors.concurrent.Frame.executeBatch(Frame.scala:202)\n\tat io.reactors.JvmScheduler$Executed$$anon$5.run(JvmScheduler.scala:255)\n\tat java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1423)\n\tat java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)\n\tat java.base/java.util.concurrent.ForkJoinPool$WorkQueue.topLevelExec(ForkJoinPool.java:1312)\n\tat java.base/java.util.concurrent.ForkJoinPool.scan(ForkJoinPool.java:1843)\n\tat java.base/java.util.concurrent.ForkJoinPool.runWorker(ForkJoinPool.java:1808)\n\tat java.base/java.util.concurrent.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:188)\njava.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat java.base/jdk.internal.org.objectweb.asm.MethodWriter.visitFrameStart(MethodWriter.java:1855)\n\tat java.base/jdk.internal.org.objectweb.asm.Frame.accept(Frame.java:1412)\n\tat java.base/jdk.internal.org.objectweb.asm.MethodWriter.computeAllFrames(MethodWriter.java:1615)\n\tat java.base/jdk.internal.org.objectweb.asm.MethodWriter.visitMaxs(MethodWriter.java:1579)\n\tat java.base/java.lang.invoke.InvokerBytecodeGenerator.methodEpilogue(InvokerBytecodeGenerator.java:287)\n\tat java.base/java.lang.invoke.InvokerBytecodeGenerator.addMethod(InvokerBytecodeGenerator.java:870)\n\tat java.base/java.lang.invoke.InvokerBytecodeGenerator.generateCustomizedCodeBytes(InvokerBytecodeGenerator.java:754)\n\tat java.base/java.lang.invoke.InvokerBytecodeGenerator.generateCustomizedCode(InvokerBytecodeGenerator.java:712)\n\tat java.base/java.lang.invoke.LambdaForm.compileToBytecode(LambdaForm.java:849)\n\tat java.base/java.lang.invoke.LambdaForm.prepare(LambdaForm.java:807)\n\tat java.base/java.lang.invoke.MethodHandle.<init>(MethodHandle.java:482)\n\tat java.base/java.lang.invoke.BoundMethodHandle.<init>(BoundMethodHandle.java:52)\n\tat java.base/java.lang.invoke.BoundMethodHandle$Species_LL.<init>(java/lang/invoke/BoundMethodHandle$Species_LL)\n\tat java.base/java.lang.invoke.BoundMethodHandle$Species_LL.make(java/lang/invoke/BoundMethodHandle$Species_LL)\n\tat java.base/java.lang.invoke.DirectMethodHandle$Holder.invokeStatic(DirectMethodHandle$Holder)\n\tat java.base/java.lang.invoke.BoundMethodHandle$Species_L.copyWithExtendL(BoundMethodHandle.java:236)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvertByEditor(MethodHandleImpl.java:333)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvert(MethodHandleImpl.java:265)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvert(MethodHandleImpl.java:382)\n\tat java.base/java.lang.invoke.MethodHandle.asTypeUncached(MethodHandle.java:905)\n\tat java.base/java.lang.invoke.MethodHandle.asType(MethodHandle.java:870)\n\tat java.base/jdk.internal.reflect.MethodHandleAccessorFactory.newConstructorAccessor(MethodHandleAccessorFactory.java:114)\n\tat java.base/jdk.internal.reflect.ReflectionFactory.newConstructorAccessor(ReflectionFactory.java:200)\n\tat java.base/java.lang.reflect.Constructor.acquireConstructorAccessor(Constructor.java:549)\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:486)\n\tat io.reactors.Platform$Reflect$.instantiate(Platform.scala:193)\n\tat io.reactors.Proto.create(Proto.scala:25)\n\tat io.reactors.concurrent.Frame.checkFresh(Frame.scala:237)\n\tat io.reactors.concurrent.Frame.processBatch(Frame.scala:491)\n\tat io.reactors.concurrent.Frame.isolateAndProcessBatch(Frame.scala:210)\n\tat io.reactors.concurrent.Frame.executeBatch(Frame.scala:183)\njava.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat java.base/java.lang.Object.clone(Native Method)\n\tat java.base/java.lang.invoke.LambdaForm.create(LambdaForm.java:337)\n\tat java.base/java.lang.invoke.LambdaForm.create(LambdaForm.java:369)\n\tat java.base/java.lang.invoke.DelegatingMethodHandle.makeReinvokerForm(DelegatingMethodHandle.java:162)\n\tat java.base/java.lang.invoke.DelegatingMethodHandle.makeReinvokerForm(DelegatingMethodHandle.java:120)\n\tat java.base/java.lang.invoke.BoundMethodHandle.makeReinvoker(BoundMethodHandle.java:111)\n\tat java.base/java.lang.invoke.DirectMethodHandle.rebind(DirectMethodHandle.java:148)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvertByEditor(MethodHandleImpl.java:289)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvert(MethodHandleImpl.java:265)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvert(MethodHandleImpl.java:382)\n\tat java.base/java.lang.invoke.MethodHandle.asTypeUncached(MethodHandle.java:905)\n\tat java.base/java.lang.invoke.MethodHandle.asType(MethodHandle.java:870)\n\tat java.base/jdk.internal.reflect.MethodHandleAccessorFactory.newConstructorAccessor(MethodHandleAccessorFactory.java:114)\n\tat java.base/jdk.internal.reflect.ReflectionFactory.newConstructorAccessor(ReflectionFactory.java:200)\n\tat java.base/java.lang.reflect.Constructor.acquireConstructorAccessor(Constructor.java:549)\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:486)\n\tat io.reactors.Platform$Reflect$.instantiate(Platform.scala:193)\n\tat io.reactors.Proto.create(Proto.scala:25)\n\tat io.reactors.concurrent.Frame.checkFresh(Frame.scala:237)\n\tat io.reactors.concurrent.Frame.processBatch(Frame.scala:491)\n\tat io.reactors.concurrent.Frame.isolateAndProcessBatch(Frame.scala:210)\n\tat io.reactors.concurrent.Frame.executeBatch(Frame.scala:183)\n\tat io.reactors.JvmScheduler$Executed$$anon$5.run(JvmScheduler.scala:255)\n\tat java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1423)\n\tat java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)\n\tat java.base/java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:667)\n\tat io.reactors.JvmScheduler$ReactorForkJoinWorkerThread.pollPool(JvmScheduler.scala:103)\n\tat io.reactors.JvmScheduler$ReactorForkJoinWorkerThread.postschedule(JvmScheduler.scala:150)\n\tat io.reactors.JvmScheduler$Executed.postschedule(JvmScheduler.scala:273)\n\tat io.reactors.concurrent.Frame.executeBatch(Frame.scala:202)\n\tat io.reactors.JvmScheduler$Executed$$anon$5.run(JvmScheduler.scala:255)\njava.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat java.base/java.util.ArrayList.grow(ArrayList.java:239)\n\tat java.base/java.util.ArrayList.grow(ArrayList.java:244)\n\tat java.base/java.util.ArrayList.add(ArrayList.java:483)\n\tat java.base/java.util.ArrayList.add(ArrayList.java:496)\n\tat java.base/java.lang.invoke.LambdaFormBuffer.noteDuplicate(LambdaFormBuffer.java:194)\n\tat java.base/java.lang.invoke.LambdaFormBuffer.replaceParameterByCopy(LambdaFormBuffer.java:373)\n\tat java.base/java.lang.invoke.LambdaFormEditor.makeArgumentCombinationForm(LambdaFormEditor.java:864)\n\tat java.base/java.lang.invoke.LambdaFormEditor.filterArgumentForm(LambdaFormEditor.java:714)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvertByEditor(MethodHandleImpl.java:331)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvert(MethodHandleImpl.java:265)\n\tat java.base/java.lang.invoke.MethodHandleImpl.makePairwiseConvert(MethodHandleImpl.java:382)\n\tat java.base/java.lang.invoke.MethodHandle.asTypeUncached(MethodHandle.java:905)\n\tat java.base/java.lang.invoke.MethodHandle.asType(MethodHandle.java:870)\n\tat java.base/jdk.internal.reflect.MethodHandleAccessorFactory.newConstructorAccessor(MethodHandleAccessorFactory.java:114)\n\tat java.base/jdk.internal.reflect.ReflectionFactory.newConstructorAccessor(ReflectionFactory.java:200)\n\tat java.base/java.lang.reflect.Constructor.acquireConstructorAccessor(Constructor.java:549)\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:486)\n\tat io.reactors.Platform$Reflect$.instantiate(Platform.scala:193)\n\tat io.reactors.Proto.create(Proto.scala:25)\n\tat io.reactors.concurrent.Frame.checkFresh(Frame.scala:237)\n\tat io.reactors.concurrent.Frame.processBatch(Frame.scala:491)\n\tat io.reactors.concurrent.Frame.isolateAndProcessBatch(Frame.scala:210)\n\tat io.reactors.concurrent.Frame.executeBatch(Frame.scala:183)\n\tat io.reactors.JvmScheduler$Executed$$anon$5.run(JvmScheduler.scala:255)\n\tat java.base/java.util.concurrent.ForkJoinTask$RunnableExecuteAction.exec(ForkJoinTask.java:1423)\n\tat java.base/java.util.concurrent.ForkJoinTask.doExec(ForkJoinTask.java:387)\n\tat java.base/java.util.concurrent.ForkJoinTask.invoke(ForkJoinTask.java:667)\n\tat io.reactors.JvmScheduler$ReactorForkJoinWorkerThread.pollPool(JvmScheduler.scala:103)\n\tat io.reactors.JvmScheduler$ReactorForkJoinWorkerThread.postschedule(JvmScheduler.scala:150)\n\tat io.reactors.JvmScheduler$Executed.postschedule(JvmScheduler.scala:273)\n\tat io.reactors.concurrent.Frame.executeBatch(Frame.scala:202)\njava.lang.OutOfMemoryError: GC overhead limit exceeded\njava.lang.OutOfMemoryError: GC overhead limit exceeded\n[2024-09-23T14:07:28.649+0100] org.renaissance.core (org.renaissance.core.Launcher main)\nSEVERE: Harness failed with java.lang.NoClassDefFoundError: Could not initialize class scala.Console$\n\tat org.renaissance.harness.RenaissanceSuite$.runBenchmarks$$anonfun$1(RenaissanceSuite.scala:201)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat org.renaissance.harness.RenaissanceSuite$.runBenchmarks(RenaissanceSuite.scala:205)\n\tat org.renaissance.harness.RenaissanceSuite$.main(RenaissanceSuite.scala:130)\n\tat org.renaissance.harness.RenaissanceSuite.main(RenaissanceSuite.scala)\n\tat java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:580)\n\tat org.renaissance.core.Launcher.loadAndInvokeHarnessClass(Launcher.java:129)\n\tat org.renaissance.core.Launcher.launchHarnessClass(Launcher.java:78)\n\tat org.renaissance.core.Launcher.main(Launcher.java:43)\nCaused by: java.lang.ExceptionInInitializerError: Exception java.lang.OutOfMemoryError: GC overhead limit exceeded [in thread \"main\"]\n\nHarness failed with \n[2024-09-23T14:07:28.649+0100] org.renaissance.core (org.renaissance.core.Launcher main)\nSEVERE: Harness failed with java.lang.NoClassDefFoundError: Could not initialize class scala.Console$\n\tat org.renaissance.harness.RenaissanceSuite$.runBenchmarks$$anonfun$1(RenaissanceSuite.scala:201)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:15)\n\tat scala.runtime.function.JProcedure1.apply(JProcedure1.java:10)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat org.renaissance.harness.RenaissanceSuite$.runBenchmarks(RenaissanceSuite.scala:205)\n\tat org.renaissance.harness.RenaissanceSuite$.main(RenaissanceSuite.scala:130)\n\tat org.renaissance.harness.RenaissanceSuite.main(RenaissanceSuite.scala)\n\tat java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:580)\n\tat org.renaissance.core.Launcher.loadAndInvokeHarnessClass(Launcher.java:129)\n\tat org.renaissance.core.Launcher.launchHarnessClass(Launcher.java:78)\n\tat org.renaissance.core.Launcher.main(Launcher.java:43)\nCaused by: java.lang.ExceptionInInitializerError: Exception java.lang.OutOfMemoryError: GC overhead limit exceeded [in thread \"main\"]\n\n",
    "avg_cpu_usage": 73.7,
    "avg_cpu_time": 93.5,
    "avg_io_time": 0.0,
    "p90_io": 0.0,
    "number_of_pauses": 0,
    "total_pause_time": 0,
    "avg_pause_time": 0,
    "pauses_per_category": {},
    "total_pause_time_per_category": {},
    "avg_pause_time_per_category": {},
    "p90_pause_time": 0,
    "throughput": 0
}